// source: gst-plugins-bad

package factory

import (
	"fmt"

	"github.com/go-gst/go-gst/gst"
)

// A bin for webrtc connections
type GstWebRTCBin struct {
	*gst.Bin
}

func NewWebRTCBinWithProperties(properties map[string]interface{}) (*GstWebRTCBin, error) {
	e, err := gst.NewElementWithProperties("webrtcbin", properties)
	if err != nil {
		return nil, err
	}
	return &GstWebRTCBin{Bin: &gst.Bin{Element: e}}, nil
}

// The remote description that is in the process of being negotiated, complete with any remote candidates that have been supplied via addIceCandidate() since the offer or answer was created

func (e *GstWebRTCBin) GetPendingRemoteDescription() (interface{}, error) {
	return e.Element.GetProperty("pending-remote-description")
}

// The overall connection state of this element
// Default: new (0)
func (e *GstWebRTCBin) GetConnectionState() (interface{}, error) {
	return e.Element.GetProperty("connection-state")
}

// The last remote description that was successfully negotiated the last time the connection transitioned into the stable state plus any remote candidates that have been supplied via addIceCandidate() since the offer or answer was created

func (e *GstWebRTCBin) GetCurrentRemoteDescription() (interface{}, error) {
	return e.Element.GetProperty("current-remote-description")
}

// The collective connection state of all ICETransport's
// Default: new (0)
func (e *GstWebRTCBin) GetIceConnectionState() (interface{}, error) {
	return e.Element.GetProperty("ice-connection-state")
}

// The local SDP description in use for this connection. Favours a pending description over the current description

func (e *GstWebRTCBin) GetLocalDescription() (interface{}, error) {
	return e.Element.GetProperty("local-description")
}

// The policy to apply for bundling
// Default: none (0)
func (e *GstWebRTCBin) SetBundlePolicy(value interface{}) error {
	return e.Element.SetProperty("bundle-policy", value)
}

func (e *GstWebRTCBin) GetBundlePolicy() (interface{}, error) {
	return e.Element.GetProperty("bundle-policy")
}

// Default duration to buffer in the jitterbuffers (in ms)
// Default: 200, Min: 0, Max: -1
func (e *GstWebRTCBin) SetLatency(value uint) error {
	return e.Element.SetProperty("latency", value)
}

func (e *GstWebRTCBin) GetLatency() (uint, error) {
	var value uint
	var ok bool
	v, err := e.Element.GetProperty("latency")
	if err != nil {
		return value, err
	}
	value, ok = v.(uint)
	if !ok {
		return value, fmt.Errorf("could not cast value to uint")
	}
	return value, nil
}

// A HTTP proxy for use with TURN/TCP of the form http://[username:password@]hostname[:port][?alpn=<alpn>]
// Default: NULL
func (e *GstWebRTCBin) SetHttpProxy(value string) error {
	return e.Element.SetProperty("http-proxy", value)
}

func (e *GstWebRTCBin) GetHttpProxy() (string, error) {
	var value string
	var ok bool
	v, err := e.Element.GetProperty("http-proxy")
	if err != nil {
		return value, err
	}
	value, ok = v.(string)
	if !ok {
		return value, fmt.Errorf("could not cast value to string")
	}
	return value, nil
}

// The STUN server of the form stun://hostname:port
// Default: NULL
func (e *GstWebRTCBin) SetStunServer(value string) error {
	return e.Element.SetProperty("stun-server", value)
}

func (e *GstWebRTCBin) GetStunServer() (string, error) {
	var value string
	var ok bool
	v, err := e.Element.GetProperty("stun-server")
	if err != nil {
		return value, err
	}
	value, ok = v.(string)
	if !ok {
		return value, fmt.Errorf("could not cast value to string")
	}
	return value, nil
}

// The local description that is in the process of being negotiated plus any local candidates that have been generated by the ICE Agent since the offer or answer was created

func (e *GstWebRTCBin) GetPendingLocalDescription() (interface{}, error) {
	return e.Element.GetProperty("pending-local-description")
}

// The remote SDP description to use for this connection. Favours a pending description over the current description

func (e *GstWebRTCBin) GetRemoteDescription() (interface{}, error) {
	return e.Element.GetProperty("remote-description")
}

// The WebRTC SCTP Transport

func (e *GstWebRTCBin) GetSctpTransport() (interface{}, error) {
	return e.Element.GetProperty("sctp-transport")
}

// The signaling state of this element
// Default: stable (0)
func (e *GstWebRTCBin) GetSignalingState() (interface{}, error) {
	return e.Element.GetProperty("signaling-state")
}

// The local description that was successfully negotiated the last time the connection transitioned into the stable state

func (e *GstWebRTCBin) GetCurrentLocalDescription() (interface{}, error) {
	return e.Element.GetProperty("current-local-description")
}

// The WebRTC ICE agent

func (e *GstWebRTCBin) SetIceAgent(value interface{}) error {
	return e.Element.SetProperty("ice-agent", value)
}

func (e *GstWebRTCBin) GetIceAgent() (interface{}, error) {
	return e.Element.GetProperty("ice-agent")
}

// The collective gathering state of all ICETransport's
// Default: new (0)
func (e *GstWebRTCBin) GetIceGatheringState() (interface{}, error) {
	return e.Element.GetProperty("ice-gathering-state")
}

// The policy to apply for ICE transport
// Default: all (0)
func (e *GstWebRTCBin) SetIceTransportPolicy(value interface{}) error {
	return e.Element.SetProperty("ice-transport-policy", value)
}

func (e *GstWebRTCBin) GetIceTransportPolicy() (interface{}, error) {
	return e.Element.GetProperty("ice-transport-policy")
}

// The TURN server of the form turn(s)://username:password@host:port. To use time-limited credentials, the form must be turn(s)://timestamp:username:password@host:port. Please note that the ':' character of the 'timestamp:username' and the 'password' encoded by base64 should be escaped to be parsed properly. This is a convenience property, use #GstWebRTCBin::add-turn-server if you wish to use multiple TURN servers
// Default: NULL
func (e *GstWebRTCBin) SetTurnServer(value string) error {
	return e.Element.SetProperty("turn-server", value)
}

func (e *GstWebRTCBin) GetTurnServer() (string, error) {
	var value string
	var ok bool
	v, err := e.Element.GetProperty("turn-server")
	if err != nil {
		return value, err
	}
	value, ok = v.(string)
	if !ok {
		return value, fmt.Errorf("could not cast value to string")
	}
	return value, nil
}
